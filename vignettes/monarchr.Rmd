---
title: "MonarchR Basics"
author: "Shawn T O'Neil"
date: "<h4>Vignette updated: <i>`r format( Sys.Date(), '%b-%d-%Y')`</i></h4>"
output:
  rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{monarchr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>


```{r, include=FALSE, message=FALSE}
library(dplyr)
library(tidygraph)
library(monarchr)

options(width = 300)
knitr::opts_chunk$set(eval = TRUE, echo = TRUE, fig.width=10)
```


### Background: Biomedical Knowledge Graphs

Knowledge graphs (KGs) represent entities (such as genes, diseases, or phenotypes) and
the relationships between them; for example that the `CFTR` gene `causes` the disease
`Cystic fibrosis`. In the [Monarch Initiative](https://monarchiniative.org) KG, this
information is stored in a *directed, labeled property graph*, with properties
attached to the entities (nodes) and relationships (edges). The [KGX format](https://github.com/biolink/kgx/blob/master/specification/kgx-format.md) used by 
Monarch provides a simple specification for KGs:

* Nodes must have an `id` property
* Nodes must have a `category` property, as a multi-valued set of category labels
* Edges must have `subject`, `predicate`, and `object` properties, representing the source, relationship, and destination of the edge.
* Nodes and edges may have additional properties, and these may be multi-valued.

In the following figure, these required properties are shown in bold:

<center>![](assets/cftr_cf_edge.png){width=90%}</center>

The `monarchr` package provides access to the cloud-hosted Monarch Initiative KG,
and [others in KGX format](https://kghub.org) via graph-database and file-based "engines", 
with a simple but flexible set of query functions. The example below finds all
of the sub-types of [Neimann-Pick Disease](https://monarchinitiative.org/MONDO:0001982), and all of the
genes associated with those. (You an use the [Monarch Initiative](https://monarchiniative.org) website to
identify IDs for genes, diseases, phenotypes and more, or `search_nodes()` described below.)


```{r}
# MONDO:0001982 Niemann-Pick Disease (13 subtypes)

g <- monarch_engine() |>
  fetch_nodes(query_ids = c("MONDO:0001982")) |>
	expand(predicates = "biolink:subclass_of", direction = "in", transitive = TRUE) |>
	expand(result_categories = "biolink:Gene")

plot(g)
g
```


Backed by `tidygraph` and `igraph`, `monarchr` is part of a larger ecosystem of graph analyses in R:

- Graph joins, filters, and other manipulation: [`tidygraph`](https://tidygraph.data-imaginist.com/)
- Visualization: 
  - ggplot-based: [`ggraph`](https://ggraph.data-imaginist.com/), 
  - Interactive: [`visNetwork`](https://datastorm-open.github.io/visNetwork/), [`threejs`](https://bwlewis.github.io/rthreejs/)
- Exploratory analyses: [`EGAnet`](https://r-ega.net/)
- Graph algorithms: 
  - Various: [`igraph`](https://r.igraph.org/reference/index.html), [`migraph`](https://cran.r-project.org/web/packages/migraph/index.html), [`netrankr`](https://github.com/schochastics/netrankr/)
  - Matching: [`iGraphMatch`](https://cran.r-project.org/web/packages/iGraphMatch/vignettes/iGraphMatch.html)
  - Graph neural networks: [`spinner`](https://rpubs.com/giancarlo_vercellino/spinner)
  - Clustering: [`clustAnalytics`](https://cran.r-project.org/web/packages/clustAnalytics/index.html)
  - Community detection: [`leidenAlg`](https://github.com/kharchenkolab/leidenAlg)
  - Link prediction: [`linkprediction`](https://cran.r-project.org/web/packages/linkprediction/index.html)
- Other:
  - Particle/force-based simulation: [`particles`](https://github.com/thomasp85/particles)
  - ... others in the reverse imports for [`igraph`](https://cran.r-project.org/web/packages/igraph/index.html)
  

<div class = "blue">
*Note*: The default `plot()` provided by `monarchr` is a work in progress with limited features. 
</div>

### Engines

Two kinds of engines are supported, providing largely the same functionality: one supporting access to [Neo4j graph databases](https://neo4j.com/), and another supporting file-based access to TSV-formatted `.tar.gz` KGs hosted at [kghub.io](https://kghub.io). Regardless of source, KGs must conform to the [KGX specification](https://github.com/biolink/kgx/blob/master/specification/kgx-format.md).

The most accessible engine provided by `monarchr` is the `monarch_engine()`, designed specifically to access the cloud-hosted [Monarch Initiative](https://monarchiniatiative.org) KG.

```{r}
monarch <- monarch_engine()
```

Using another Neo4j database via `neo4j_engine()` is as simple as specifying a Neo4j [Bolt](https://neo4j.com/docs/operations-manual/current/configuration/ports/) endpoint, and username and password if required. This may be used to host your own Neo4j database for efficient KG access, based on the Monarch Neo4j [docker deployment](https://github.com/monarch-initiative/monarch-neo4j). 

```{r eval=FALSE}
neodb <- neo4j_engine("http://localhost:7687", username = "user", password = "pass")
```

Finally, the `file_engine()` provides KG access to KGX-formatted, `.tar.gz` files containing tab-separated `*_nodes.tsv` and `*_edges.tsv` files. The package comes bundled with a version of the MONDO ontology KG for demonstration purposes. You can also provide a local file path, or a URL to a remote file, which will be downloaded to the current working directory.

```{r}
filename <- system.file("extdata", "mondo_kgx_tsv.tar.gz", package = "monarchr")
# filename <- "https://kghub.io/kg-obo/mondo/2024-03-04/mondo_kgx_tsv.tar.gz"

mondo <- file_engine(filename)
```

### Fetching Nodes

Engines support a `fetch_nodes()` function for pulling nodes by specified criteria. It returns a `tidygraph`-based graph, but only nodes, not any edges that may connect them. These can be specified as a set of IDs:

```{r}
g <- monarch |>
	fetch_nodes(query_ids = c("MONDO:0009061", "HGNC:1884"))

g
```
Nodes can also be fetched in bulk. For example, we can fetch all of the nodes where `in_taxon_label` equals `"Homo sapiens"`. For demonstration purposes, we'll limit the number of results to 20 (ordered by node ID).

```{r}
h_sapiens_nodes <- monarch |>
	fetch_nodes(in_taxon_label == "Homo sapiens", limit = 20)
h_sapiens_nodes
```

While the syntax does not support all R expressions (for compatibility with database-backed engines), 
standard comparisons `==`, `!=`, `<=`, `>=`, `<`, and `>` are, as are logical operators `&`, `|`, and `!`,
and grouping with `()`s. Since many node properties are multi-valued, we provide a special `%in_list%`
operator to allow exact match against entries. Here we fetch all the *Homo sapiens* Genes, using `%in_list%` to account for the multi-valued nature of node `category`.^[The `%in_list%` and other operators work the same
for `file_engine()`s, which store multi-valued properties in list columns where `%in%` does not provide the desired semantics. Note that `%in_list%` can only take a length-one character vector as the left-hand side, and the right hand side must be a single
node property name in the KG.]

```{r}
human_genes <- monarch |>
	fetch_nodes(in_taxon_label == "Homo sapiens" & "biolink:Gene" %in_list% category, 
							limit = 20)

human_genes
```

A convenience `%~%` operator provides regular-expression matching against node properties (but not multi-valued
ones like `category`).

```{r}
fibrosis_disease_matches <- monarch |>
	fetch_nodes(description %~% ".*[fF]ibrosis.*" & "biolink:Disease" %in_list% category,
							limit = 20)
fibrosis_disease_matches
```
### Expanding

From a set of nodes (and possibly edges that connect them), we can "expand" by fetching their collective neighborhood from the KG engine. Here we fetch 10 Gene nodes, and in the first call to `expand()` fetch nodes connected by `biolink:causes` or `biolink:gene_associated_with_condition` predicates. We then take the resulting graph (which contains both disease and gene nodes), and fetch the neighborhood of nodes with category `biolink:PhenotypicFeature`. Since there are many such results, we add a `limit` for the visualization.^[The `limit` parameter for `expand()` is more complex than for `fetch_nodes()`, because the query graph also contains edges which may be part of the neighborhood that would be fetched; `expand()` attempts to fetch `limit` new edges that are not part of the query already. Further, unlike in `fetch_nodes()` where nodes are ordered by ID, edges returned by `expand()` have no explicit order, and results with `limit` should not be considered reproducible or representative.]

```{r}
# MONDO:0018982, MONDO:0011871: Neimann-Pick type B and C

g <- monarch |>
	fetch_nodes(query_ids = c("MONDO:0018982", "MONDO:0011871")) |>
	expand(predicates = c("biolink:causes", "biolink:gene_associated_with_condition")) |>
	expand(result_categories = c("biolink:PhenotypicFeature"), limit = 10)

plot(g)
```
We can limit the expansion based on several factors, which are combined in an "and" fashion:

- `direction`: `"in`", `"out"`, or `"both"` (default): which direction edges should point from the query graph nodes
- `predicates`: a character vector of edge predicates to fetch (all if unspecified)
- `result_categories`: a character vector of node category labels to fetch in the connected neighborhood (all if unspecified)

The `drop_unused_query_nodes` parameter (which defaults to `FALSE`) keeps only the nodes that are part of the recently-expanded neighborhood. For example, given a query graph with many diseases, if we try to fetch neighboring phenotypes, setting this to `TRUE` removes those disease nodes without any phenotypes.

Lastly, the `transitive` parameter (which defaults to `FALSE`) can be used to fetch hierarchical, transitive relationships like `biolink:subclass_of`. When using `transitive = TRUE`, direction must be `"in"` or `"out"`, and `predicates` must be a single entry. The first example above illustrated this; here we explore the super-types and sub-types of Niemann-Pick, by first fetching all of its subtypes, and then considering the collective ancestry of those nodes in the KG. Not all ancestors are diseases (e.g. `biolink:Entity`), so we restrict the result set of the second expansion.

```{r}
# MONDO:0001982 Niemann-Pick Disease (13 subtypes)

hierarchy <- monarch |>
  fetch_nodes(query_ids = c("MONDO:0001982")) |>
	expand(predicates = "biolink:subclass_of", direction = "in", transitive = TRUE) |>
	expand(predicates = "biolink:subclass_of", direction = "out", transitive = TRUE, result_categories = "biolink:Disease")

plot(hierarchy)
```

### Monarch Features

While `fetch_nodes()` and `expand()` apply to all types of engines, `monarchr` also exposes functionality specific
to the Monarch Initiatives' API services. The first of these is `monarch_search()`, which uses the same search API as the Monarch [website](https://monarchinitiative.org), returning a graph with matching nodes backed by a `monarch_engine()`.

```{r}
cf_hits <- monarch_search("Cystic fibrosis", category = "biolink:Disease", limit = 5)

cf_hits
```



<!-- As with `neo4j_engine()`, the `search_nodes()` function uses a regex-based search against specific node properties, configurable via engine "preferences." -->

<!-- ## Engine Preferences -->

<!-- Knowledge graphs provide a very broad range of information. Both nodes and edges have many properties--for cystic fibrosis these include `name`, `description`, `provided_by`, and `in_taxon_label`, to name a few. Some of those properties take multiple values, including the important `category` property for nodes--for cystic fibrosis this property includes `biolink:BiologicalEntity`, `biolink:Disease`, `biolink:Entity`, `biolink:NamedThing`, and `biolink:ThingWithTaxon`, again to name just a few. -->

<!-- With so much information available, it can be helpful to prioritize the most immediately relevant. This is handled in `monarchr` by engines, which are created with a set of *preferences* to specify how graph data are represented. The set of defaults can be reviewed via an engine's `preferences`: -->

<!-- ```{r file_engine_default_prefs, eval=TRUE, echo=TRUE} -->
<!-- filename <- system.file("extdata", "mondo_kgx_tsv.tar.gz", package = "monarchr") -->

<!-- e <- file_engine(filename) -->

<!-- e$preferences -->
<!-- ``` -->
<!-- These preferences affect the following behavior: -->

<!-- - `category_priority`: a vector of node `category` values to prioritize when determining the `pcategory` (primary category) column. If any category values in the node match one of these, the first preferences-specified one is used, otherwise the first category listed for the node is used. -->
<!-- - `node_search_properties`: a vector of node properties to search when using `search_nodes()`. Does not apply to `monarch_engine()` which uses the Monarch keyword search API. -->
<!-- - `node_property_priority`: specifies which node property columns should be listed first when printing. -->
<!-- - 'edge_property_priority': specifies which edgeproperty columns should be listed first when printing. -->

<!-- These can be overridden when creating an engine; in this example, we specify for a `file_engine()` that `search_nodes()` should only apply to the `name` property: -->

<!-- ```{r file_engine, eval=TRUE, echo=TRUE} -->
<!-- filename <- system.file("extdata", "mondo_kgx_tsv.tar.gz", package = "monarchr") -->
<!-- g <- file_engine(filename, -->
<!-- 								 preferences = list(node_search_properties = c("name"))) |> -->
<!-- 	search_nodes("cystic fibrosis", limit = 5) -->

<!-- g -->
<!-- ``` -->

<!-- # Searching and Fetching Nodes -->

<!-- *Note: the functions described here fetch nodes from a knowledge graph, but not any edges between them. See `expand()` below for querying relationships.* -->

<!-- As mentioned above, `search_nodes()` uses the Monarch search API when used with a `monarch_engine()`, but a regex-based field search when using a file-based or generic Neo4j engine. In these latter cases, the search term is expanded as `.*<search term>.*` to match within longer text, and allows the inclusion of regular expression syntax, e.g. `(cystic fibrosis)|(CFTR)`.  -->

<!-- For all engines, `search_nodes()` provides a `category` parameter to limit the matching nodes to those with one of the specified categories, and a `limit` parameter to limit the number of resulting nodes. -->

<!-- ```{r search_fancy, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!-- 	search_nodes("cystic fibrosis", category = c("biolink:Gene", "biolink:PhenotypicFeature"), limit = 50) -->

<!-- g -->
<!-- ``` -->

<!-- Nodes can also be fetched with the `fetch_nodes()` function. Specifying a set of `query_ids` fetches just those nodes: -->

<!-- ```{r fetch_nodes_query_ids, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!-- 	fetch_nodes(query_ids = c("MONDO:0009061", "HGNC:1884")) -->

<!-- g -->
<!-- ``` -->

<!-- We can also get nodes in bulk by specifying an expression over node properties; `fetch_nodes()` also supports a `limit` parameter, -->
<!-- which we use here just to keep the size of the query small (the `monarch_engine()` will fetch large numbers of nodes, but this is  -->
<!-- slow compared to file-based KGs). -->

<!-- ```{r fetch_nodes_taxon, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!-- fetch_nodes(in_taxon_label == "Homo sapiens", limit = 5) -->

<!-- g -->
<!-- ``` -->

<!-- The `%in_list%` infix function to query for existence of an entry in a multi-valued property like `category`.^[R's `%in%` isn't appropriate in this case, because it does not work as a membership filter values in list columns.] Let's get some diseases. -->


<!-- ```{r fetch_nodes_diseases, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!-- fetch_nodes("biolink:Disease" %in_list% category, limit = 5) -->

<!-- g -->
<!-- ``` -->

<!-- This special `%in_list%` operator is limited: it only supports length-one vectors on the left hand side and node property names on the right hand side. A query like `c("biolink:Disease", "biolink:Gene") %in_list% category` will not work, neither will something like `in_taxon_label %in_list% c("Homo sapiens", "Mus musculus")`. Fortunately, the query syntax supports combinations with `&` and `|` like regular R syntax: -->

<!-- ```{r fetch_nodes_diseases_multi, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!--   fetch_nodes("biolink:Disease" %in_list% category | ("biolink:Gene" %in_list% category & in_taxon_label == "Homo sapiens"), limit = 5) -->

<!-- g -->
<!-- ``` -->

<!-- See `help(fetch_nodes)` for more details. Finally, note that `pcategory` (the "primary category") is not a queryable property, since it is not part of the knowledge graph being accessed by the engine, but rather added by the engine as part of the fetched result. -->


<!-- # Expanding on a Query Graph -->

<!-- The `search_nodes()` and `fetch_nodes()` functions retrieve sets of nodes from a knowledge graph engine, but they do not provide any associated edges. Instead, edges (and the nodes they connect to) are added to a query graph by "expanding" into the larger KG provided by the engine. This example first fetches the node for cystic fibrosis, and then expands the resulting graph by fetching all nodes connected by `biolink:has_phenotype` relationships.^[Actually, an engine does this expansion, by taking a query graph and expanding into it's backing KG. We can call `expand()` directly on a previously generated graph however, because graphs remember their most-recent engine, and pass the request onto that engine. In theory, this architecture allows connecting information across multiple engines and knowledge graphs, but this has not been developed or tested yet.] -->

<!-- ```{r expand_1, eval=TRUE, echo=TRUE} -->
<!-- g <- monarch_engine() |> -->
<!--   fetch_nodes(query_ids = c("MONDO:0009061")) |> -->
<!-- 	expand(predicates = "biolink:has_phenotype") -->

<!-- g -->
<!-- ``` -->

<!-- Here, `fetch_nodes()` is used to fetch a single node from the engine; this is passed to `expand()` to find nodes  -->




































<!-- MonarchR is designed to support user-friendly queries against Knowledge Graphs -->
<!-- (KGs), specifically the cloud-hosted [Monarch Initiative](https://monarchinitiative.org) KG, -->
<!-- or other [KGX formatted](https://github.com/biolink/kgx/blob/master/specification/kgx-format.md) KGs available at [kghub.org](https://kghub.org). -->

<!-- To support these different data sources, large knowledge graphs are represented -->
<!-- as *engines*. The easiest engine to use is the `monarch_engine()`, which we -->
<!-- can use to get nodes  -->


<!-- It is in early development and testing, and relies upon publicly-available services managed by the Monarch Initiative. -->

<!-- Briefly, a graph stored in a local variable represents a subsets of nodes and/or edges from the larger KG. These local graphs are also [`tidygraph`](https://tidygraph.data-imaginist.com/) objects (which are [igraph](https://r.igraph.org/)s) providing a large range of graph-related functionality. -->

<!-- First, let's load some useful libraries: -->

<!-- ```{r library, message=FALSE} -->
<!-- library(monarchr) -->
<!-- library(dplyr) -->
<!-- library(tidygraph) -->
<!-- #library(kableExtra) # for kbl() table output formatting -->
<!-- #library(ggraph) -->
<!-- #library(ggiraph) -->
<!-- ``` -->

<!-- ### Searching by ID or Keyword -->

<!-- The `query_ids()` function returns matching nodes, while `monarch_search()` function uses the keyword search [API](https://api-v3.monarchinitiative.org/v3/docs), returning up to `limit` nodes. Neither function returns any edges that might exist between those nodes. -->

<!-- ```{r search} -->
<!-- # id lookup -->
<!-- eds_hits <- query_ids(c("MONDO:0007525", "MONDO:0020066", "MONDO:0034021")) -->
<!-- # or search -->
<!-- eds_hits <- monarch_search("Ehlers-danlos syndrome", limit = 3) -->


<!-- nodes(eds_hits) -->
<!-- edges(eds_hits) -->
<!-- ``` -->

<!-- ### Easily manipulate node or edge data -->

<!-- Tidygraphs are stored as node and edge dataframes; we can "activate" one or the other to manipulate it, or extract it with `as_tibble()`. Let's add a `source` to these nodes of `"search"`, and print the node table. -->

<!-- ```{r manipulate} -->
<!-- eds_hits <- eds_hits %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	mutate(source = "search") %>% -->
<!-- 	select(id, source, everything()) # move new source col to 2nd position -->

<!-- nodes(eds_hits) -->
<!-- ``` -->

<!-- ### PCategory -->

<!-- The `pcategory` column is a unique addition of MonarchR: typically, nodes are annotated with multiple categories, which is stored in the `category` field in the KG. These tend to relate to ontological concepts, in that a `biolink:Disease` is also a `biolink:BiologicalEntity` and `biolink:NamedThing`. Typically, one of these is most of interest in application. Rather than try and determine this "primary" category of interest from the data, we set a priority list of categories to use, choosing the first available prioritized category, or the first category available as a fallback. This can be configured via the `kg_prefs` option should you so choose: -->

<!-- ```{r pcategory} -->
<!-- options("kg_prefs") -->
<!-- ``` -->

<!-- ### Neighborhood Summarization -->

<!-- Let's see what kinds of connections exist in the broader graph for these nodes, which is a good idea before we go and fetch some of them. We can summarize the nodes in the surrounding neighborhood, or the edges: -->

<!-- ```{r neighborhood} -->
<!-- library(knitr) -->
<!-- summarize_neighborhood(eds_hits, summarize = "nodes") -->
<!-- summarize_neighborhood(eds_hits, summarize = "edges") -->
<!-- ``` -->

<!-- Looking at the neighborhood node summary, there are quite a few phenotypes connected to these diseases, 30 other diseases, and 3 genes. -->

<!-- To see what kinds types of relationships these are, we can look at the neighborhood edge summary, which breaks down the set of edges connected to these nodes in a more complex way. Each row represents a set of connections from *query* nodes in our graph `g`, to *result* nodes in the surrounding neighborhood, broken out by the category of the query and result nodes. Note that predicate may be either direction here: result genes -cause-\> our query diseases, but our query diseases -have-\> result phenotypes. Finally, for accuracy the grouping is actually the full category list and the `pcategory` is defined from those, but in practice `pcategory` is a good descriptor. -->

<!-- ### Fetching edges -->

<!-- In this example we can see that there are two links from our diseases (potentially from the same one) to genes via `biolink:gene_associated_with_disease`, and one connected to a gene via `biolink:causes`. There are also two kinds of connections to Phenotypes: `biolink:has_phenotype` and `biolink:has_mode_of_inheritance`. Let's fetch the connections to genes: -->

<!-- ```{r fetch-edges} -->
<!-- eds_with_genes <- eds_hits |> -->
<!-- 	fetch_edges(result_categories = "biolink:Gene") -->

<!-- eds_with_genes -->
<!-- ``` -->

<!-- Notice that our `source` column is still there: we added it as a custom column to the `nodes` data earlier, but now new nodes have been been filled with `NA` values. We can fix this up as we pull in the data. This ability to easily modify, filter and otherwise manipulate the graph data via tabular primitives is a powerful feature of `tidygraph`, this [blog post](https://www.data-imaginist.com/posts/2017-07-07-introducing-tidygraph/) is a good introduction to more. -->

<!-- ```{r fetch-deges-2} -->
<!-- eds_with_genes <- eds_hits |> -->
<!-- 	fetch_edges(result_categories = "biolink:Gene") |> -->
<!-- 	activate(nodes) |> -->
<!-- 	mutate(source = replace_na(source, "genelinks")) -->

<!-- eds_with_genes -->
<!-- # summarize the outgoing edges connected to the graph so far -->
<!-- # summarize_neighborhood(eds_with_genes, direction = "out", summarize = "edges") -->
<!-- ``` -->

<!-- The `fetch_edges` function allows us to narrow which edges to fetch by specifying the directionality, as well as sets of predicates and result (neighborhood) node categories allowed. We have diseases and connected genes: let's pull in further connections to either Phenotypes or Genes, via outgoing has_phenotype or interacts_with relationships: -->

<!-- ```{r fetch-edges-3} -->
<!-- eds_with_genes_phenos_expanded <- eds_with_genes |> -->
<!-- 	fetch_edges(direction = "out",  -->
<!-- 							predicates = c("biolink:has_phenotype", "biolink:interacts_with"), -->
<!-- 							result_categories = c("biolink:Gene", "biolink:PhenotypicFeature")) -->

<!-- eds_with_genes_phenos_expanded -->
<!-- ``` -->

<!-- ### Visualization -->

<!-- Let's create a quick visualization: -->

<!-- ```{r visualization} -->
<!-- ggraph(eds_with_genes_phenos_expanded, layout = "fr") + -->
<!-- 	geom_edge_link(aes(color = predicate)) + -->
<!-- 	geom_node_point(aes(color = pcategory)) -->
<!-- ``` -->

<!-- ### Graph joins -->

<!-- For our next trick, let's find all the phenotypes connected to genes associated with FA and Cystic Fibrosis. We'll then find the intersection of those phenotypes with an inner join on the nodes. -->

<!-- ```{r graph-joins} -->
<!-- fa <- monarch_search("Fanconi anemia", limit = 1) %>% -->
<!-- 	fetch_edges(result_categories = "biolink:Gene") %>% -->
<!-- 	fetch_edges(direction = "out", predicates = "biolink:has_phenotype") -->

<!-- cf <- monarch_search("Cystic Fibrosis", limit = 1) %>% -->
<!-- 	fetch_edges(result_categories = "biolink:Gene") %>% -->
<!-- 	fetch_edges(direction = "out", predicates = "biolink:has_phenotype") -->

<!-- shared_nodes <- inner_join(nodes(fa), nodes(cf)) -->
<!-- shared_nodes -->
<!-- ``` -->

<!-- Let's see these in context, by doing a full join on our EDS and CF graphs, then keeping only nodes that are either diseases, genes, or one of these shared phenotypes: -->

<!-- ```{r graph-joins-2} -->
<!-- merged <- fa %>% -->
<!-- 	graph_join(cf) %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	filter(pcategory %in% c("biolink:Gene", "biolink:Disease") | id %in% shared_nodes$id) -->

<!-- ggraph(merged, layout = "fr") + -->
<!-- 	geom_edge_link(aes(color = predicate)) + -->
<!-- 	geom_node_point(aes(color = pcategory)) -->
<!-- ``` -->

<!-- ### Transitivity -->

<!-- The `fetch_edges` function can also be used to fetch edges transitively. For example, if we were to try and look for genes connected to the first hit for Ehlers-Danlos Syndrome, we would find none. However, we can use the `transitive` parameter to find genes connected to diseases that are subclasses of Ehlers-Danlos Syndrome, and then pull in the genes from there. -->

<!-- ```{r transitivity} -->
<!-- eds_with_subtypes <- monarch_search("Ehlers-danlos syndrome", limit = 1) |> -->
<!-- 	fetch_edges(direction = "in", predicates = "biolink:subclass_of", transitive = TRUE) |> -->
<!-- 	fetch_edges(result_categories = "biolink:Gene") -->

<!-- # plot -->
<!-- ggraph(eds_with_subtypes, layout = "sugiyama") + -->
<!-- 	geom_edge_link(aes(color = predicate)) + -->
<!-- 	geom_node_point(aes(color = pcategory)) + -->
<!-- 	coord_flip() -->
<!-- ``` -->

<!-- When using `transitive = TRUE`, each relationship type will traversed separately and the results joined. It's always wise to use `transitive = TRUE` with caution, as it can result in a large number of edges being fetched, and always indicate a direction of `"in"` or `"out"` to avoid fetching the entire KG. -->

<!-- ### Ancestors and Descendants -->

<!-- With some creativity, we do quite quite a lot with these few primitives. For example, from an initial search of 5 hits for EDS, we can visualize all of their ancestors. We can do the same for descendants. Note that these will find edges between the nodes in the search results, as well as intermediate nodes. -->

<!-- ```{r ancestors-descendants} -->
<!-- eds_search <- monarch_search("Ehlers-danlos syndrome", limit = 5) %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	mutate(source = "search") -->

<!-- eds_search_ancestors <- eds_search |> -->
<!-- 	fetch_edges(direction = "out", predicates = "biolink:subclass_of", transitive = TRUE) %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	mutate(source = replace_na(source, "ancestors")) -->

<!-- eds_search_descendants <- eds_search |> -->
<!-- 	fetch_edges(direction = "in", predicates = "biolink:subclass_of", transitive = TRUE) %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	mutate(source = replace_na(source, "descendants")) -->

<!-- ggraph(eds_search_ancestors, layout = "sugiyama") + -->
<!-- 		geom_edge_link(aes(color = predicate)) + -->
<!-- 		geom_node_point(aes(color = source)) + -->
<!-- 		coord_flip() -->

<!-- ggraph(eds_search_descendants, layout = "sugiyama") + -->
<!-- 		geom_edge_link(aes(color = predicate)) + -->
<!-- 		geom_node_point(aes(color = source)) + -->
<!-- 		coord_flip() -->
<!-- ``` -->

<!-- Let's see the full join of this data, and if we take the inner join of the nodes, we should see just how our 5 search results are connected to each other (via intermediary nodes if necessary). -->

<!-- ```{r ancestors-descendants-2} -->
<!-- merged <- eds_search_ancestors |>  -->
<!-- 	graph_join(eds_search_descendants) -->

<!-- ggraph(merged, layout = "sugiyama") + -->
<!-- 		geom_edge_link(aes(color = predicate)) + -->
<!-- 		geom_node_point(aes(color = source)) + -->
<!-- 		coord_flip() -->

<!-- inner <- eds_search_ancestors %>% -->
<!-- 	activate(nodes) %>% -->
<!-- 	inner_join(nodes(eds_search_descendants)) -->

<!-- ggraph(inner, layout = "sugiyama") + -->
<!-- 		geom_edge_link(aes(color = predicate)) + -->
<!-- 		geom_node_point(aes(color = source)) + -->
<!-- 		coord_flip() -->
<!-- ``` -->

<!-- ### Lists of graphs -->

<!-- As a functional language, R provides powerful features for working with lists of data. In this example we begin with a graph with 5 disease nodes of interest; we use `explode()` to split the graph into a list of 5 single-node graphs, then use `lapply()` to work with these in parallel, fetching neighborhoods, extracting the nodes data, and removing the original searched nodes based on the `source` column we added earlier. -->

<!-- ```{r list-of-graphs} -->
<!-- eds_search %>%                                                 # starting with a graph with 5 disease nodes -->
<!-- 	explode() %>%                                                # split into a list of 5 single-node graphs -->
<!-- 	lapply(fetch_edges) %>%                                      # fetch neighborhood edges for each graph  -->
<!-- 	lapply(nodes) %>%                                            # extract nodes df from each graph -->
<!-- 	lapply(function(nodes_df) {filter(nodes_df, is.na(source))}) # remove original searched nodes from each df -->
<!-- ``` -->

<!-- ## Session info -->

<!-- ```{r} -->
<!-- utils::sessionInfo() -->
<!-- ``` -->

